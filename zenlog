#!/bin/bash

set -e

usage() {
  cat <<'EOF'

Zenlog

  Start a new shell where all input/output from each command will be saved
  in a separate file.

Usage:
  zenlog [-d LOG_DIR]
    Start a new shell.

  zenlog -p DAYS
    Purge logs older than N days and exit.

  . <(zenlog -s)
     Install the helper functions on a bash-like shell.
     Commands are:
      - zenlog_prompt_marker
          Print the command separator marker. Include it in the prompt.
          Example:
            PS1="$(zenlog_prompt_marker) > "

      - 184 COMMAND [args...]
          Run the passed command without logging the output.
          Example:
            184 emacs

      - in_zenlog
          Return success if alreay in zenlog.
          Example:
            in_zenlog && echo "in zenlog"

      - zenlog_last_log [-r] [-n N] [-p ZENLOG_PID]
          Print the last sanitized log filename.
          -r will print the raw log filename instead.
          -n to specify which previous log to show -- default is 1 to show the
             last log.  0 is current, 2 is the second last.
          -p to show other zenlog's log file instead.

      - zenlog_open_last_log [-r] [-n N] [-p ZENLOG_PID]
          Open the last sanitized log with $ZENLOG_VIEWER or $PAGER.
          -r, -n, -p have the same meaning as zenlog_last_log.

      - zenlog_cat_last_log [-r] [-n N] [-p ZENLOG_PID]
          Cat the last sanitized log.
          -r, -n, -p have the same meaning as zenlog_last_log.

      - zenlog_history [-r] [-n N] [-p ZENLOG_PID]
          Show the last N sanitized log filenames.
          -r will show the raw log filenames instead.
          -r, -n, -p have the same meaning as zenlog_last_log
            except when -n is omitted it'll show all the log files in the
            history.

          $ZENLOG_HISTSIZE is used as the history size. (default=20)

      - zenlog_echo_command COMMAND [opts...]
          If you use this to echo back the command line that's being
          executed in the pre-exec hook, zenlog will recognize the
          current command and perform auto-184.
          See also ZENLOG_ALWAYS_184.

      - zenlog_du
          Execute du on the log directory.
          Example:
            zenlog_du -h

  Environmental variables:
    ZENLOG_DIR
          Specify log file directory.

    ZENLOG_ALWAYS_184
          Specify executable names that shouldn't be logged.
          Needs to be used with zenlog_echo_command.
          Example: export ZENLOG_ALWAYS_184="vi emacs man"

EOF
  exit 1
}

# TOOD: Rewrite all in perl.
# TODO: Add completion helper and find from recent logs.

name=$(basename "$0")

# Optionally get environmental variables from ~/.zenlogrc
if [[ -f "$HOME/.zenlogrc" ]] ; then
  . "$HOME/.zenlogrc"
fi

temp=${TEMP:-${TMP:-/tmp}}
log_dir=${ZENLOG_DIR:-${temp}/zenlog}

shell_helper=0
purge_days=-1
purge_yes=0
ZENLOG_START_COMMAND="$SHELL -l"

while getopts "sd:hp:yc:" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG" ;;
    p) purge_days="$OPTARG" ;;
    y) purge_yes=1 ;;
    c) ZENLOG_START_COMMAND="$OPTARG" ;;
    *) usage;
  esac
done
shift $(($OPTIND - 1))

if (( $purge_days >= 0 )) ; then
  if ! (( $purge_yes )) ; then
    echo -n "$name: Purging logs older than $purge_days days? (y/N) "
    read res
    [[ "$res" == "y" ]] || [[ "$res" == "Y" ]] || exit 1
  fi
  # First, remove old log files.
  find "$log_dir" -mindepth 1 \( -type f -o -type l \) -ctime +$(( $purge_days - 1 )) -delete

  # Remove broken links.
  find "$log_dir" -xtype l -delete

  # Then, remove all empty directories.
  for n in 1 2 3 4 5 6; do
    find "$log_dir" -mindepth 1 -type d -empty -delete
  done
  exit 0
fi

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  zenlog uses it to split log files.
_zenlog_prompt_marker=$(echo -e '\e[0m\e[1m\e[00000m')
zenlog_prompt_marker() {
  echo $_zenlog_prompt_marker
}

_zenlog_remove_marker=$(echo -e '\e[0m\e[5m\e[00000m')
zenlog_remove_marker() {
  echo $_zenlog_remove_marker
}

zenlog_perlpid() {
  zenlog_fail_if_not_in_zenlog || return 1
  cat "$ZENLOG_TEMP_DIR/zenlog-${ZENLOG_PID}-perlpid.txt"
}

_zenlog_pause_marker=$(echo -e '\e[0m\e[6m\e[00000m')
zenlog_pause_marker() {
  echo $_zenlog_pause_marker
}

_zenlog_resume_marker=$(echo -e '\e[0m\e[7m\e[00000m')
zenlog_resume_marker() {
  echo $_zenlog_resume_marker
}

zenlog_pause() {
  echo $_zenlog_pause_marker >/dev/tty
}

zenlog_resume() {
  echo $_zenlog_resume_marker >/dev/tty
}

# execute command without logging output.
zenlog_nolog() {
  echo -en '\e[0m\e[2m\e[00000m'
  "${@}"
}

alias 184=zenlog_nolog

# Use it to avoid ZENLOG_ALWAYS_184.
zenlog_no_auto_184() {
  "${@}"
}
alias 186=zenlog_no_auto_184

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  echo -en "\e[0m\e[3m\e[00000m$(tr -s '\r\n' '  ' <<< "${*}")\e[0m\e[4m\e[00000m"
  echo -e "\e[0m"
}

in_zenlog() {
  [[ "$ZENLOG_TTY" == $(tty) ]]
}

zenlog_fail_if_not_in_zenlog() {
  if ! in_zenlog ; then
    echo "zenlog: Error: not in zenlog." 1>&2
    return 1
  fi
  return 0
}

zenlog_history() {
  zenlog_fail_if_not_in_zenlog || return 1

  local pid=$ZENLOG_PID
  local type="san"
  local raw=0
  local nth=""

  local OPTIND
  local OPTARG
  while getopts "rp:n:" opt; do
    case "$opt" in
      r) type=raw; raw=1 ;;
      p) pid="$OPTARG" ;;
      n) nth="$OPTARG" ;;
      *) return 1;;
    esac
  done
  shift $(($OPTIND - 1))

  local self=0
  (( $pid == $ZENLOG_PID )) && self=1

  local hist
  if [[ "$nth" == "0" ]] ; then
    hist="$ZENLOG_TEMP_DIR"/zenlog-${pid}-current.txt
  else
    hist="$ZENLOG_TEMP_DIR"/zenlog-${pid}-history.txt
  fi
  {
    if (( $raw )) ; then
      sed -e 's!/SAN/!/RAW/!' "$hist"
    else
      cat "$hist"
    fi
  } | {
    if [[ -n "$nth" ]] ; then
      tail -n $(( $nth + 1 )) | head -1
    else
      cat
    fi
  }
}

zenlog_last_log() {
  # Provide the default "n" at the beginning, so it can be overridden.
  zenlog_history -n 1 "${@}"
}

zenlog_open_viewer() {
  local file="$1"
  if [[ -n "$file" ]] ; then
    echo "zenlog: Opening $file ..."
    ${ZENLOG_VIEWER:-$PAGER} "$file"
  fi
}

zenlog_open_last_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  zenlog_open_viewer "$(zenlog_last_log "${@}")"
}

zenlog_cat_last_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  cat "$(zenlog_last_log "${@}")"
}

zenlog_cat_last_log_content() {
  zenlog_fail_if_not_in_zenlog || return 1

  sed -e "1,/^COMMAND:/d" -e "/^\x1b\[0m\x1b\[5m\x1b\[00000m/d" -- "$(zenlog_last_log "${@}" -r)"
}

# Useful: when used with -p PID.
zenlog_current_log() {
  zenlog_history -n 0 "${@}"
}

# Useful: when used with -p PID.
zenlog_open_current_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  zenlog_open_viewer "$(zenlog_current_log "${@}")"
}

zenlog_show_running_commands() {
  cat "$ZENLOG_TEMP_DIR"/zenlog-*-stat.txt
  # TODO Don't show from dead PIDs.
}

zenlog_du() {
  du "${ZENLOG_CUR_LOG_DIR:-$ZENLOG_DIR}" "$@"
}

EOF
  exit 0
fi

# Start

if [[ "$ZENLOG_TTY" == $(tty) ]] ; then
  echo "$name: Error: already in zenlog." 1>&2
  exit 1
fi

export ZENLOG_TEMP_DIR="${temp}"
export ZENLOG_PID=$$
export ZENLOG_HISTORY="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-history.txt
export ZENLOG_CURRENT="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-current.txt
export ZENLOG_PERLPID="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-perlpid.txt
export ZENLOG_STAT="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-stat.txt
trap 'rm -f "$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-*.txt' EXIT
: ${ZENLOG_HISTSIZE:=20}
export ZENLOG_HISTSIZE

: ${ZENLOG_ALWAYS_184:=}
export ZENLOG_ALWAYS_184

export ZENLOG_START_COMMAND
export ZENLOG_CUR_LOG_DIR=$log_dir

# Example: (builtin|time)
export ZENLOG_COMMAND_PREFIX=${ZENLOG_COMMAND_PREFIX:-}

echo "$name: Logging to $ZENLOG_CUR_LOG_DIR ..."

# TODO: the -c part doesn't work on all shells.
script -qf \
    -c 'export ZENLOG_TTY=$(tty); $ZENLOG_START_COMMAND' \
    >(perl -w <(cat <<'EOF'
#line 334
use strict;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $zenlog_pid = $ENV{ZENLOG_PID};
my $log_dir = $ENV{ZENLOG_CUR_LOG_DIR};
my $history_file = $ENV{ZENLOG_HISTORY};
my $history_size = $ENV{ZENLOG_HISTSIZE};
my $current_file = $ENV{ZENLOG_CURRENT};
my $stat_file = $ENV{ZENLOG_STAT};
my $bg_viwer = $ENV{ZENLOG_BG_VIEWER};
my %always_iyayo = map {$_ => 1} split(/\s+/, $ENV{ZENLOG_ALWAYS_184});
my $command_prefix = $ENV{ZENLOG_COMMAND_PREFIX};

my ($raw, $san, $cur_raw_name, $cur_san_name);

my @history = ();

{
  open(my $hf, ">$ENV{ZENLOG_PERLPID}");
  print $hf ($$, "\n");
  close($hf);
}

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
  undef $cur_raw_name;
  undef $cur_san_name;
}

sub logging() {
  return defined $cur_raw_name;
}

sub create_prev_links($$$) {
  my ($raw, $san, $link_dir) = @_;

  unlink("${link_dir}/rrrrrr");
  rename("${link_dir}/rrrrr", "${link_dir}/rrrrrr");
  rename("${link_dir}/rrrr" , "${link_dir}/rrrrr");
  rename("${link_dir}/rrr"  , "${link_dir}/rrrr");
  rename("${link_dir}/rr"   , "${link_dir}/rrr");
  rename("${link_dir}/r"    , "${link_dir}/rr");

  unlink("${link_dir}/pppppp");
  rename("${link_dir}/ppppp", "${link_dir}/pppppp");
  rename("${link_dir}/pppp" , "${link_dir}/ppppp");
  rename("${link_dir}/ppp"  , "${link_dir}/pppp");
  rename("${link_dir}/pp"   , "${link_dir}/ppp");
  rename("${link_dir}/p"    , "${link_dir}/pp");

  symlink($raw, "${link_dir}/r");
  symlink($san, "${link_dir}/p");
}

# Create symlinks.
sub create_links($$) {
  my ($dir, $name) = @_;

  # Normalzie.
  $name =~ s! \s+ $!!xg;
  $name =~ s! [ / \s ]+ !_!xg;

  # Avoid typical errors...
  return if $name =~ m!^ ( \. | \.\. ) $!x;

  my $t = time;

  my $command_dir = "$log_dir/$dir/$name/";
  my $raw_dir = sprintf('%s/RAW/%s/',
      $command_dir,
      strftime('%Y/%m/%d', localtime($t)));
  $raw_dir =~ s!/+!/!g;
  my $san_dir = $raw_dir =~ s!/RAW/!/SAN/!r;

  make_path($raw_dir);
  make_path($san_dir);

  my $raw_file = ($cur_raw_name =~ s!^.*/!!r);
  my $san_file = ($cur_san_name =~ s!^.*/!!r);

  symlink($cur_raw_name, "$raw_dir$raw_file");
  symlink($cur_san_name, "$san_dir$san_file");

  create_prev_links($cur_raw_name, $cur_san_name, $command_dir);
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;

  my $raw_name = sprintf('%s/RAW/%s.%03d-%05d-%04d.log',
      $log_dir,
      strftime('%Y/%m/%d/%H-%M-%S', localtime($t)),
      ($t - int($t)) * 1000, $zenlog_pid, $seq++);
  $raw_name =~ s!/+!/!g;
  my $san_name = $raw_name =~ s!/RAW/!/SAN/!r;

  make_path(dirname($raw_name));
  make_path(dirname($san_name));

  $cur_raw_name = $raw_name;
  $cur_san_name = $san_name;

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  $raw->autoflush();
  $san->autoflush();

  push @history, $san_name;
  if (@history > $history_size) {
    @history = @history[-$history_size .. -1];
  }

  {
    open(my $hf, ">$current_file");
    print $hf ($san_name, "\n");
    close($hf);
  }
  {
    open(my $hf, ">$history_file");
    for my $h (@history) {
      print $hf ($h, "\n");
    }
    close($hf);
  }

  create_prev_links($raw_name, $san_name, $log_dir);
  create_links("pids", $zenlog_pid)
}

sub write_log($) {
  return unless defined $raw;

  my ($l) = @_;
  $raw->print($l);

  # Sanitize
  $l =~ s! (
        \a                         # Bell
        | \e \x5B .*? [\x40-\x7E]  # CSI
        | \e \x5D .*? \x07         # Set terminal title
        | \e \( .                  # 3 byte sequence
        | \e [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CR/LFs.
  $l =~ s! \s* \x0d* \x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \s* \x0d !\x0a!gx;             # Replace orphan CRs with LFs.

  # Also replace ^H's.
  $l =~ s! \x08 !^H!gx;
  $san->print($l) if defined $san;
}

sub write_stat($) {
  my ($command) = @_;
  open(my $s, ">$stat_file");
  print $s ($zenlog_pid, "\t", ($command =~ tr!\t! !r), "\n");
  close($s);
}

sub stop_log() {
  write_log("[retracted]\n");
  close_log();
}

sub extract_tag($) {
  my ($file) = @_;

  return "" unless $file =~ m!\#\s*([^\#]+)$!;
  my $tag = $1;

  $tag =~ s! \s+ $ !!x;

  return $tag;
}

open_log();

my $paused = 0;

while (defined(my $line = <>)) {
  if ($paused) {
    if ($line =~ m! \e\[0m\e\[7m\e\[00000m !x) {
      $paused = 0;
    }
    next;
  }

  if ($line =~ m! \e\[0m\e\[6m\e\[00000m !x) {
    $paused = 1;
    next;
  }

  # Command line and output marker.
  if ($line =~ m! \e\[0m\e\[3m\e\[00000m (.*?) \e\[0m\e\[4m\e\[00000m !x) {
    my $command = $1;
    write_log($line);
    write_log("COMMAND: $command\n");
    write_stat($command);

    for my $single_command ( split(/(?: \&\& | \|\|? | \; )/x, $command)) {
      $single_command =~ s!^ [ \s \( ]+ !!x; # Remove prefixing ('s.

      # Remove prefixes, such as "builtin" and "time".
      while ($single_command =~ s!^$command_prefix\s+!!o) {
      }

      my $exe = (split(/\s+/, $single_command, 2))[0];

      $exe =~ s!^ \\ !!x; # Remove first '\'.
      $exe =~ s!^ .*/ !!x; # Remove file path

      if (exists($always_iyayo{$exe})) {
        stop_log();
      } else {
        create_links("cmds", $exe);
      }
    }
    my $tag = extract_tag($command);
    create_links("tags", $tag) if $tag and logging();
    next;
  }

  if ($line =~ m! ^ (.*?)  \e\[0m\e\[1m\e\[00000m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();
    write_stat("");

    write_log($post);

    next;
  }
  if ($line =~ m!^ (.*?) \e\[0m\e\[2m\e\[00000m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    stop_log();

    next;
  }

  write_log($line);
}
close_log()
EOF
) )

echo "$name done." 1>&2

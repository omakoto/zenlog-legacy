#!/bin/bash

set -e

usage() {
  cat <<'EOF'

Zenlog

  Start a new shell where all input/output from each command will be saved
  in a separate file.

Usage:
  zenlog [-d LOG_DIR]
    Start a new shell.

  zenlog -p DAYS
    Purge logs older than N days and exit.

  . <(zenlog -s)
     Install the helper functions on a bash-like shell.
     Commands are:
      - zenlog_prompt_marker
          Print the command separator marker. Include it in the prompt.
          Example:
            PS1="$(zenlog_prompt_marker) > "

      - 184 COMMAND [args...]
          Run the passed command without logging the output.
          Example:
            184 emacs

      - in_zenlog
          Return success if alreay in zenlog.
          Example:
            in_zenlog && echo "in zenlog"

      - zenlog_last_log [-r] [-n N] [-p ZENLOG_PID]
          Print the last sanitized log filename.
          -r will print the raw log filename instead.
          -n to specify which previous log to show -- default is 1 to show the
             last log.  0 is current, 2 is the second last.
          -p to show other zenlog's log file instead.

      - zenlog_open_last_log [-r] [-n N] [-p ZENLOG_PID]
          Open the last sanitized log with $ZENLOG_VIEWER or $PAGER.
          -r, -n, -p have the same meaning as zenlog_last_log.

      - zenlog_cat_last_log [-r] [-n N] [-p ZENLOG_PID]
          Cat the last sanitized log.
          -r, -n, -p have the same meaning as zenlog_last_log.

      - zenlog_history [-r] [-n N] [-p ZENLOG_PID] [-a]
          Show the last N sanitized log filenames.
          -r will show the raw log filenames instead.
          -r, -n, -p have the same meaning as zenlog_last_log
            except when -n is omitted it'll show all the log files in the
            history.
          -a will use find to show all actual log files.

          $ZENLOG_HISTSIZE is used as the history size. (default=20)

      - zenlog_echo_command COMMAND [opts...]
          If you use this to echo back the command line that's being
          executed in the pre-exec hook, zenlog will recognize the
          current command and perform auto-184.
          See also ZENLOG_ALWAYS_184.

      - zenlog_du
          Execute du on the log directory.
          Example:
            zenlog_du -h

  Environmental variables:
    ZENLOG_DIR
          Specify log file directory.

    ZENLOG_ALWAYS_184
          Specify executable names that shouldn't be logged.
          Needs to be used with zenlog_echo_command.
          Example: export ZENLOG_ALWAYS_184="vi emacs man"

EOF
  exit 1
}

# TOOD: Rewrite all in perl.
# TODO: Add completion helper and find from recent logs.

name=$(basename "$0")

# Optionally get environmental variables from ~/.zenlogrc
if [[ -f "$HOME/.zenlogrc" ]] ; then
  . "$HOME/.zenlogrc"
fi

temp=${TEMP:-${TMP:-/tmp}}
log_dir=${ZENLOG_DIR:-${temp}/zenlog}

shell_helper=0
purge_days=-1
purge_yes=0
ZENLOG_START_COMMAND="$SHELL -l"

while getopts "sd:hp:yc:" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG" ;;
    p) purge_days="$OPTARG" ;;
    y) purge_yes=1 ;;
    c) ZENLOG_START_COMMAND="$OPTARG" ;;
    *) usage;
  esac
done
shift $(($OPTIND - 1))

if (( $purge_days >= 0 )) ; then
  if ! (( $purge_yes )) ; then
    echo -n "$name: Purging logs older than $purge_days days? (y/N) "
    read res
    [[ "$res" == "y" ]] || [[ "$res" == "Y" ]] || exit 1
  fi
  # First, remove old log files.
  find "$log_dir" -type f -ctime +$(( $purge_days - 1 )) \
      -name '*.log' | xargs rm -f
  # Then, remove all empty directories.
  rmdir "$log_dir"/* 2>/dev/null || true
  exit 0
fi

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  zenlog uses it to split log files.
_zenlog_prompt_marker=$(echo -e '\e[0m\e[1m\e[00000m')
zenlog_prompt_marker() {
  echo $_zenlog_prompt_marker
}

_zenlog_remove_marker=$(echo -e '\e[0m\e[5m\e[00000m')
zenlog_remove_marker() {
  echo $_zenlog_remove_marker
}

zenlog_perlpid() {
  zenlog_fail_if_not_in_zenlog || return 1
  cat "$ZENLOG_TEMP_DIR/zenlog-${ZENLOG_PID}-perlpid.txt"
}

_zenlog_pause_marker=$(echo -e '\e[0m\e[6m\e[00000m')
zenlog_pause_marker() {
  echo $_zenlog_pause_marker
}

_zenlog_resume_marker=$(echo -e '\e[0m\e[7m\e[00000m')
zenlog_resume_marker() {
  echo $_zenlog_resume_marker
}

zenlog_pause() {
  echo $_zenlog_pause_marker >/dev/tty
}

zenlog_resume() {
  echo $_zenlog_resume_marker >/dev/tty
}

# execute command without logging output.
zenlog_nolog() {
  echo -en '\e[0m\e[2m\e[00000m'
  "${@}"
}

alias 184=zenlog_nolog

# Use it to avoid ZENLOG_ALWAYS_184.
zenlog_no_auto_184() {
  "${@}"
}
alias 186=zenlog_no_auto_184

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  echo -en "\e[0m\e[3m\e[00000m$(tr -s '\r\n' '  ' <<< "${*}")\e[0m\e[4m\e[00000m"
  echo -e "\e[0m"
}

in_zenlog() {
  [[ "$ZENLOG_TTY" == $(tty) ]]
}

zenlog_fail_if_not_in_zenlog() {
  if ! in_zenlog ; then
    echo "zenlog: Error: not in zenlog." 1>&2
    return 1
  fi
  return 0
}

zenlog_history() {
  zenlog_fail_if_not_in_zenlog || return 1

  local pid=$ZENLOG_PID
  local type="san"
  local raw=0
  local nth=""
  local show_command=0
  local command_filter=""
  local all=0
  local really_all=0

  local OPTIND
  local OPTARG
  while getopts "rp:n:cf:aA" opt; do
    case "$opt" in
      r) type=raw; raw=1 ;;
      p) pid="$OPTARG" ;;
      n) nth="$OPTARG" ;;
      c) show_command=1 ;;
      f) command_filter=$(sed -e 's!  *!.*!g' <<<"$OPTARG") ;;
      a) all=1 ;;
      A) really_all=1 ;;
    esac
  done
  shift $(($OPTIND - 1))

  local self=0
  (( $pid == $ZENLOG_PID )) && self=1

  local hist
  if [[ "$nth" == "0" ]] ; then
    hist="$ZENLOG_TEMP_DIR"/zenlog-${pid}-current.txt
  else
    hist="$ZENLOG_TEMP_DIR"/zenlog-${pid}-history.txt
  fi
  {
    if (( $all )) ; then
      # sort -r | sed is needed to ignore previous sessions
      # with the same pid.
      find "$ZENLOG_CUR_LOG_DIR" -type f \
          -name "*-$pid-*-$type.log" |
          sort -r | sed -e '/-0-...\.log$/q'| sort
    elif (( $really_all )) ; then
      find "$ZENLOG_CUR_LOG_DIR" -type f \
          -name "*-$type.log" | sort
    else
      if (( $raw )) ; then
        sed -e 's!/SAN/!/RAW/!' "$hist"
      else
        cat "$hist"
      fi
    fi
  } | {
    while read file ; do
      command=$( sed -ne '/^COMMAND: /{
        s/^COMMAND: //p
        q
      }
      ' "$file")
      if [[ -z "$command_filter" ]] ||
          grep -q -- "$command_filter" <<<"$command" ; then
        if (( $show_command )) ; then
          echo -n "$file"
          echo -en "\t"
          echo "$command"
        else
          echo "$file"
        fi
      fi
    done
  } | {
    if [[ -n "$nth" ]] ; then
      tail -n $(( $nth + 1 )) | head -1
    else
      cat
    fi
  }
}

zenlog_last_log() {
  # Provide the default "n" at the beginning, so it can be overridden.
  zenlog_history -n 1 "${@}"
}

zenlog_open_viewer() {
  local file="$1"
  if [[ -n "$file" ]] ; then
    echo "zenlog: Opening $file ..."
    ${ZENLOG_VIEWER:-$PAGER} "$file"
  fi
}

zenlog_open_last_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  zenlog_open_viewer "$(zenlog_last_log "${@}")"
}

zenlog_cat_last_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  cat "$(zenlog_last_log "${@}")"
}

zenlog_cat_last_log_content() {
  zenlog_fail_if_not_in_zenlog || return 1

  sed -e "1,/^COMMAND:/d" -e "/^\x1b\[0m\x1b\[5m\x1b\[00000m/d" -- "$(zenlog_last_log "${@}" -r)"
}

# Useful: when used with -p PID.
zenlog_current_log() {
  zenlog_history -n 0 "${@}"
}

# Useful: when used with -p PID.
zenlog_open_current_log() {
  zenlog_fail_if_not_in_zenlog || return 1

  zenlog_open_viewer "$(zenlog_current_log "${@}")"
}

zenlog_show_running_commands() {
  cat "$ZENLOG_TEMP_DIR"/zenlog-*-stat.txt
  # TODO Don't show from dead PIDs.
}

zenlog_du() {
  du "${ZENLOG_CUR_LOG_DIR:-$ZENLOG_DIR}" "$@"
}

EOF
  exit 0
fi

# Start

if [[ "$ZENLOG_TTY" == $(tty) ]] ; then
  echo "$name: Error: already in zenlog." 1>&2
  exit 1
fi

export ZENLOG_TEMP_DIR="${temp}"
export ZENLOG_PID=$$
export ZENLOG_HISTORY="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-history.txt
export ZENLOG_CURRENT="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-current.txt
export ZENLOG_PERLPID="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-perlpid.txt
export ZENLOG_STAT="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-stat.txt
trap 'rm -f "$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-*.txt' EXIT
: ${ZENLOG_HISTSIZE:=20}
export ZENLOG_HISTSIZE

: ${ZENLOG_ALWAYS_184:=}
export ZENLOG_ALWAYS_184

export ZENLOG_CUR_LOG_DIR=$log_dir

echo "$name: Logging to $ZENLOG_CUR_LOG_DIR ..."

export ZENLOG_START_COMMAND

# TODO: the -c part doesn't work on all shells.
script -qf \
    -c 'export ZENLOG_TTY=$(tty); $ZENLOG_START_COMMAND' \
    >(perl -w <(cat <<'EOF'
#line 367
use strict;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $zenlog_pid = $ENV{ZENLOG_PID};
my $log_dir = $ENV{ZENLOG_CUR_LOG_DIR};
my $history_file = $ENV{ZENLOG_HISTORY};
my $history_size = $ENV{ZENLOG_HISTSIZE};
my $current_file = $ENV{ZENLOG_CURRENT};
my $stat_file = $ENV{ZENLOG_STAT};
my $bg_viwer = $ENV{ZENLOG_BG_VIEWER};
my %always_iyayo = map {$_ => 1} split(/\s+/, $ENV{ZENLOG_ALWAYS_184});

my ($raw, $san, $cur_raw_name, $cur_san_name);

my @history = ();

{
  open(my $hf, ">$ENV{ZENLOG_PERLPID}");
  print $hf ($$, "\n");
  close($hf);
}

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;

  my $raw_name = sprintf('%s/RAW/%s.%03d-%s-%d.log',
      $log_dir,
      strftime('%Y/%m/%d/%H-%M-%S', localtime($t)),
      ($t - int($t)) * 1000, $zenlog_pid, $seq++);
  $raw_name =~ s!/+!/!g;
  my $san_name = $raw_name =~ s!/RAW/!/SAN/!r;

  make_path(dirname($raw_name));
  make_path(dirname($san_name));

  $cur_raw_name = $raw_name;
  $cur_san_name = $san_name;

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  $raw->autoflush();
  $san->autoflush();

  push @history, $san_name;
  if (@history > $history_size) {
    @history = @history[-$history_size .. -1];
  }

  {
    open(my $hf, ">$current_file");
    print $hf ($san_name, "\n");
    close($hf);
  }
  {
    open(my $hf, ">$history_file");
    for my $h (@history) {
      print $hf ($h, "\n");
    }
    close($hf);
  }
}

sub write_log($) {
  return unless defined $raw;

  my ($l) = @_;
  $raw->print($l);

  # Sanitize
  $l =~ s! (
        \a                         # Bell
        | \e \x5B .*? [\x40-\x7E]  # CSI
        | \e \x5D .*? \x07         # Set terminal title
        | \e \( .                  # 3 byte sequence
        | \e [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CL/LFs.
  $l =~ s! \s* \x0d* \x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \s* \x0d !\x0a!gx;             # Replace orphan CRs with LFs.

  # Also replace ^H's.
  $l =~ s! \x08 !^H!gx;
  $san->print($l) if defined $san;
}

sub write_stat($) {
  my ($command) = @_;
  open(my $s, ">$stat_file");
  print $s ($zenlog_pid, "\t", ($command =~ tr!\t! !r), "\n");
  close($s);
}

sub stop_log() {
  write_log("[retracted]\n");
  close_log();
}

open_log();

my $paused = 0;

while (defined(my $line = <>)) {
  if ($paused) {
    if ($line =~ m! \e\[0m\e\[7m\e\[00000m !x) {
      $paused = 0;
    }
    next;
  }

  if ($line =~ m! \e\[0m\e\[6m\e\[00000m !x) {
    $paused = 1;
    next;
  }

  # Command line and output marker.
  if ($line =~ m! \e\[0m\e\[3m\e\[00000m (.*?) \e\[0m\e\[4m\e\[00000m !x) {
    my $command = $1;
    write_log($line);
    write_log("COMMAND: $command\n");
    write_stat($command);

    $command =~ s!^[\s\(]+!!; # Remove prefixing ('s.
    my $exe = (split(/\s+/, $command, 2))[0];

    $exe =~ s!^.*/!!; # Remove file path

    if (exists($always_iyayo{$exe})) {
      stop_log();
    } else {
      # Create symlink
      my $t = time;

      # TODO It's supposed to be a "temporary" hack... clean it up...
      my $command_dir = "${log_dir}/commands/${exe}/";
      my $raw_dir = sprintf('%s/RAW/%s/',
          $command_dir,
          strftime('%Y/%m/%d', localtime($t)));
      $raw_dir =~ s!/+!/!g;
      my $san_dir = $raw_dir =~ s!/RAW/!/!r;

      make_path($raw_dir);
      make_path($san_dir);

      my $raw_file = ($cur_raw_name =~ s!^.*/!!r);
      my $san_file = ($cur_san_name =~ s!^.*/!!r);

      symlink($cur_raw_name, "$raw_dir$raw_file");
      symlink($cur_san_name, "$san_dir$san_file");

      unlink("${command_dir}rrrrrr");
      rename("${command_dir}rrrrr", "${command_dir}rrrrrr");
      rename("${command_dir}rrrr", "${command_dir}rrrrr");
      rename("${command_dir}rrr", "${command_dir}rrrr");
      rename("${command_dir}rr", "${command_dir}rrr");
      rename("${command_dir}r", "${command_dir}rr");

      unlink("${command_dir}pppppp");
      rename("${command_dir}ppppp", "${command_dir}pppppp");
      rename("${command_dir}pppp", "${command_dir}ppppp");
      rename("${command_dir}ppp", "${command_dir}pppp");
      rename("${command_dir}pp", "${command_dir}ppp");
      rename("${command_dir}p", "${command_dir}pp");

      symlink($cur_raw_name, "${command_dir}/r");
      symlink($cur_san_name, "${command_dir}/p");
    }

    next;
  }

  if ($line =~ m! ^ (.*?)  \e\[0m\e\[1m\e\[00000m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();
    write_stat("");

    write_log($post);

    next;
  }
  if ($line =~ m!^ (.*?) \e\[0m\e\[2m\e\[00000m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    stop_log();

    next;
  }

  write_log($line);
}
close_log()
EOF
) )

echo "$name done." 1>&2

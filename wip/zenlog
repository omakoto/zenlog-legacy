#!/usr/bin/perl -w

use strict;
use FindBin;
use lib "$FindBin::Bin";
use POSIX;
use Getopt::Long;
use Zenlog;
use ZenlogCommands;

use constant DEBUG => Zenlog::DEBUG;

sub start_zenlog() {

  print "START! -- WIP\n";
  exit 0;

  $ENV{ZENLOG_PID} = $$;
  $ENV{ZENLOG_OUTER_TTY} = `tty` or die "$0: Unable to get tty: $!\n";

  my ($reader_fd, $writer_fd) = POSIX::pipe();
  $reader_fd or die "$0: pipe() failed: $!\n";

  printf STDERR ("# pipe opened, read=%d, write=%d\n",
      $reader_fd, $writer_fd) if DEBUG;

  if (my $pid = fork()) {
    POSIX::close($reader_fd);
    # Parent
    exec("script",
      "-fqc",
      "export ZENLOG_TTY=\$(tty); exec /bin/bash -l",
      "/proc/self/fd/$writer_fd") or die "$0: failed to start script: $!\n";
  }
  # Child
  POSIX::close($writer_fd);
  open(my $reader, "<&=", $reader_fd) or die "$0: fdopen failed: $!\n";

  while (defined(my $line = <$reader>)) {
    print ">>> ", $line;
  }
  print "Logger finishing.\n";
}

#---------------------------------------------------------------------
# Start
#---------------------------------------------------------------------

sub main(@) {
  my (@args) = @_;

  my $my_dir = $0 =~ s!/[^/]+?$!!r; #!

  # If no arguments are provided, start new zenlog.
  if (@args == 0) {
    Zenlog::fail_if_in_zenlog;
    start_zenlog;
  }

  my $subcommand = shift @args;
  my $subcommand_us = $subcommand =~ s!-!_!gr; #!
  my $subcommand_hy = $subcommand =~ s!_!-!gr; #!

  if (exists $ZenlogCommands::commands{$subcommand_us}) {
    exit(&{$ZenlogCommands::commands{$subcommand_us}} ? 0 : 1);
  }
  for my $command (
      "zenlog-$subcommand",
      "zenlog-$subcommand_hy",
      "zenlog_$subcommand_us") {
    # Find along with PATH, but check the script dir first.
    for my $path ($my_dir, split(/:/, $ENV{PATH})) {
      my $c = "$path/$command";
      if (-x $c) {
        exec($c, @args) or exit 1;
      }
    }
  }

  die "$0: Unknown subcommand '$subcommand'.\n";
}

main(@ARGV);

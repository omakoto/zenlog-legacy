#!/usr/bin/perl -w
# -*- perl-mode -*-

# Not done.  Almost working, but even after script finishes, the reader doesn't finish.

# TODO: Add completion helper and find from recent logs.

use strict;
use Getopt::Std;
use POSIX qw( strftime );
use Time::HiRes qw(time);
use File::Path qw(make_path);
use File::Basename;

# See if already in zenlog.
# TODO: Fix this logic; it won't be true if a new terminal is opened as a
#   child process.  Need to get the name of tty created by script.  But how?

$ENV{IN_ZENLOG} and die("$0: Already in zenlog.\n");

$ENV{IN_ZENLOG} = 1;

my %opts = ();

getopts('sd:b', \%opts);

# Show shell helper functions.
# Usage: . <(zenlog -s)
if ($opts{s}) {
    print <<'EOF';

# Show it in the prompt.  zenlog uses it to split log files.
zenlog_prompt_marker() {
  echo -e '\e[0m\e[1m\e[0m'
}

# execute command without logging output.
zenlog_iyayo() {
  echo -en '\e[0m\e[2m\e[0m'
  "${@}"
  return 1
}
alias 184=zenlog_iyayo

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  echo -en "\e[0m\e[3m\e[0m\x1b[1;36m${*}\e[0m\e[4m\e[0m"
  echo -e "\x1b[0m"
}

in_zenlog() {
  (( $IN_ZENLOG ))
}

EOF
    exit 0;
}

my $buffering = $opts{b};
my $log_dir = ($opts{d} or $ENV{ZENLOG_DIR} or "/tmp/zenlog");

# Start.

my ($read_fd, $write_fd) = POSIX::pipe();

my $cpid = fork();
if (!$cpid) {
    # child, writer.
    POSIX::close $read_fd;

    my $opts = "-q";
    $opts .= "f" unless $buffering;

    system("script", $opts, "/dev/fd/$write_fd");
    POSIX::close $write_fd;
    print "$0: done.\n";
    exit 0;
}
POSIX::close $write_fd;
open(my $read, "<&=", $read_fd) or die;

print "$0: Logging to $log_dir ...\n";

# Prepare log files.

my ($raw, $san, $raw_name, $san_name);

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;
  my $filename = sprintf('%s/%s.%03d-%s-%d',
      $log_dir,
      strftime('%Y-%m-%d/%H:%M:%S', localtime($t)),
      ($t - int($t)) * 1000, $$, $seq++);

  make_path(dirname($filename));

  $raw_name = "${filename}-raw.log";
  $san_name = "${filename}-san.log";

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  if (!$buffering) {
    $raw->autoflush();
    $san->autoflush();
  }
}

sub write_log($) {
  my ($l) = @_;
  $raw->print($l) if defined $raw;

  # Sanitize
  $l =~ s! (
        \a                           # Bell
        | \x1b \x5B .*? [\x40-\x7E]  # CSI
        | \x1b \x5D .*? \x07         # Set terminal title
        | \x1b [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CL/LFs.
  $l =~ s! \x0d+\x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \x0d !\x0a!gx; # Replace orphan CRs with LFs.
  $san->print($l) if defined $san;
}

# Main loop.

open_log();

while (defined(my $l = <$read>)) {
  # Command line and output marker.
  $l =~ s! \x1b\[0m\x1b\[3m\x1b\[0m !\nCOMMAND:\n!xg;
  $l =~ s! \x1b\[0m\x1b\[4m\x1b\[0m !\nOUTPUT:!xg;

  if ($l =~ m! ^ (.*?)  \x1b\[0m\x1b\[1m\x1b\[0m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();

    write_log($post);

  } elsif ($l =~ m!^ (.*?) \x1b\[0m\x1b\[2m\x1b\[0m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    write_log("[retracted]\n");

    close_log();

  } else {
    write_log($l);
  }
}
close_log();

waitpid($cpid, 0);
#print "$0: child done.\n";
exit 0;

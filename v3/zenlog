#!/usr/bin/env ruby2.1

require 'pathname';

DEBUG = (ENV["ZENLOG_DEBUG"].to_i >= 0);

if (DEBUG)
  require "yaml";
end

# Show debug message.
def debug(*message)
  return unless DEBUG;
  print "\x1b[0m\x1b[1;31m", message.join(""), "\x1b[0m";
end

#-----------------------------------------------------------
# Constants
#-----------------------------------------------------------

PROMPT_MARKER =         "\x1b[0m\x1b[1m\x1b[00000m";
NO_LOG_MARKER =         "\x1b[0m\x1b[4m\x1b[00000m";
COMMAND_START_MARKER =  "\x1b[0m\x1b[5m\x1b[00000m";
COMMAND_END_MARKER =    "\x1b[0m\x1b[6m\x1b[00000m";

RC_FILE =  "#{ENV['HOME']}/.zenlogrc.rb";

#-----------------------------------------------------------
# Configuration (loads .zenlogrc.rb)
#-----------------------------------------------------------
class ZenConfig
  attr_reader :start_command;
  attr_reader :log_dir;
  attr_reader :prefix_commands;
  attr_reader :always_no_log_commands;

  # Load the RC file if exists, and return the configuration.
  def self.load()
    # Load the RC file if exists.
    if File.exist?(RC_FILE)
      debug("Loading ", RC_FILE, " ...\n");
      require RC_FILE;
    end

    # Create and return a new config instance.
    config = ZenConfig.new(
        get_env('ZENLOG_START_COMMAND', "#{ENV['SHELL']} -l"),
        get_env('ZENLOG_DIR', "/tmp/zenlog/"),
        get_env('ZENLOG_PREFIX_COMMANDS', "(?:builtin|time|sudo)"),
        get_env('ZENLOG_ALWAYS_184_COMMANDS',
        "(?:vi|vim|man|nano|pico|less|watch|emacs|zenlog.*)"));

    debug("Config:\n");
    debug(config.to_yaml);
    return config;
  end

private
  def initialize(start_command, log_dir, prefix_commands, always_no_log_commands)
    @start_command = start_command;
    @log_dir = log_dir;
    @prefix_commands = prefix_commands;
    @always_no_log_commands = always_no_log_commands;
  end

  # Load an environmental variable, with a default value.
  def self.get_env(env_name, default)
    val = ENV[env_name]
    return val ? val : default;
  end
end

#-----------------------------------------------------------
# Utility methods.
#-----------------------------------------------------------

# Escape a string for shell.
def shescape(str)
  if %r![^a-zA-Z0-9\-\.\_\/]!.match(str)
    return "'" + str.gsub(%r!'!, %q['\\\\'']) + "'";
  else
    return str
  end
end
# shescape + convert ESC's to '\e'.
def shescape_ee(str)
  return shescape(str).gsub(%r!\x1b!, '\\\\e');
end

# Return the tty.
def get_tty()
  return %x[tty 2>/dev/null].chomp;
end

# Return true if in zenlog.
def in_zenlog()
  return ENV['ZENLOG_TTY'] == get_tty;
end

# Die if in zenlog.
def fail_if_in_zenlog()
  abort "Already in zenlog." if in_zenlog;
end

# Die if *not* in zenlog.
def fail_unless_in_zenlog()
  abort "Not in zenlog." unless in_zenlog;
end

#-----------------------------------------------------------
# Subcommands.
#-----------------------------------------------------------
module ZenCommands
  def self.prompt_marker(args)
    print PROMPT_MARKER;
    return true;
  end

  def self.no_log_marker(args)
    print NO_LOG_MARKER;
    return true;
  end

  def self.no_log(args)
    print no_log_marker;
    return true;
  end

  def self.outer_tty(args)
    return false unless in_zenlog;
    print ENV['ZENLOG_OUTER_TTY'], "\n";
    return true
  end

  def self.ensure_log_dir(args)
    dir = ENV['ZENLOG_DIR'];
    abort "$ZENLOG_DIR not set." unless dir;
    return true;
  end

  def self.show_command(args)
    # Don't fail, so PS0 would still be safe without zenlog.
    return false unless in_zenlog;
    print(COMMAND_START_MARKER, args.join(" "), COMMAND_END_MARKER);
    return true;
  end

  def self.sh_helper(args)
    # Note in this script, ESC characters are converted into "\e", so that
    # output from the set command won't contain special characters.

    #------------------------------------
    output = <<'EOF';
# Equivalent to zenlog in-zenlog.  Inlined for performance.
function in_zenlog() {
  [[ "$ZENLOG_TTY" == $(tty) ]]
}

# Run a command without logging the output.
function zenlog_nolog() {
  echo -e %s
  "${@}"
}
alias 184=zenlog_nolog

# Run a command *with* logging the output, ignoring ZENLOG_ALWAYS_184_COMMANDS.
function zenlog_no_auto_184() {
  # Note it doesn't have to do anything -- 186 will just fool zenlog.pl
  # and make it misunderstand the actual command name.
  "${@}"
}
alias 186=zenlog_no_auto_184

EOF
    #------------------------------------
    printf(output,
        shescape_ee(NO_LOG_MARKER),
        );
    return true;
  end

end

#-----------------------------------------------------------
# Core.
#-----------------------------------------------------------
class Zenlog
  def initialize()
    @config = ZenConfig.load;
  end

  def start()
    export_env

    reader, writer = IO.pipe;
    writer.close_on_exec = false;
    debug "Pipe opened: reader=", reader.fileno, " writer=", writer.fileno, "\n";

    child_pid = fork;
    if !child_pid
      debug ">> In child.\n";
      start_script writer;
      # We never get here.
    end

    debug ">> In parent.\n";
    writer.close
    start_logger reader;
    Process.waitpid child_pid

    return true
  end


private
  def start_script(writer)
    command = ["script",
        "-fqc",
        "export ZENLOG_TTY=\$(tty); exec #{@config.start_command}",
        "/proc/self/fd/#{writer.fileno}"];
    debug("Starting: ", command.map{|s| shescape s}.join(" "), "\n");
    exec *command, close_others: false;

    # exec failed. TODO Looks like we really won't get here?
    STDERR.puts("exec failed.")
    kill 'INT', Process.ppid;
    exit 1;
  end

  def start_logger(reader)
    reader.each do |line|
      print ">>>", line;
    end
  end

  def export_env()
    ENV['ZENLOG_PID'] = Process.pid.to_s;
    ENV['ZENLOG_OUTER_TTY'] = get_tty;
    ENV['ZENLOG_DIR'] = @config.log_dir;

    # Deprecated; it's just for backward compatibility.  Don't use it.
    ENV['ZENLOG_CUR_LOG_DIR'] = @config.log_dir;
  end
end

#-----------------------------------------------------------
# Entry point.
#-----------------------------------------------------------
def main(args)
  # If no arguments are provided, start zenlog.
  if args.length == 0
    return Zenlog.new.start;
  end

  # Otherwise it's a subcommand.

  exe_dir = Pathname.new($0).realpath.dirname.to_s;
  debug("zenlog path=", exe_dir, "\n");

  subcommand = args.shift;
  debug "Subcommand: ", subcommand, "\n";

  subcommand_us = subcommand.gsub(/-/, "_");
  subcommand_hy = subcommand.gsub(/_/, "-");

  # First, see if it's an intrinsic command.
  if ZenCommands.respond_to?(subcommand_us)
    exit ZenCommands.send(subcommand_us, args) ? 0 : 1;
  end

  # It's not an intrinsic command. See if there's
  # executable.
  [   "zenlog-#{subcommand}",
      "zenlog-#{subcommand_hy}",
      "zenlog_#{subcommand_us}"].each do |command|
    [exe_dir, ENV['PATH'].split(":")].flatten.each do |dir|
      fullpath = "#{dir}/#{command}";
      if File.executable? fullpath
        exec fullpath, *args;
      end
    end
  end
end

main ARGV;
